/**
 * generated by Xtext 2.14.0
 */
package nl.sudohenk.xtext.generator;

import com.google.common.base.Objects;
import java.util.LinkedList;
import java.util.List;
import nl.sudohenk.xtext.generator.MessageGenerator;
import nl.sudohenk.xtext.generator.StateMachineTrace;
import nl.sudohenk.xtext.generator.Utils;
import nl.sudohenk.xtext.stateDef.Message;
import nl.sudohenk.xtext.stateDef.MessageTransition;
import nl.sudohenk.xtext.stateDef.State;
import nl.sudohenk.xtext.stateDef.StateMachine;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class StateDefGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    try {
      EObject _head = IteratorExtensions.<EObject>head(resource.getAllContents());
      final StateMachine sm = ((StateMachine) _head);
      if ((sm != null)) {
        String _name = sm.getName();
        String _plus = (_name + ".dot");
        fsa.generateFile(_plus, this.generateGlobalDotGraph(sm));
        final MessageGenerator messageGen = new MessageGenerator(sm);
        final Function1<Message, Boolean> _function = (Message m) -> {
          int _size = m.getStructEntries().size();
          return Boolean.valueOf((_size > 0));
        };
        Iterable<Message> _filter = IterableExtensions.<Message>filter(sm.getMessages(), _function);
        for (final Message message : _filter) {
          fsa.generateFile(Utils.getFileNameForMessage(message), messageGen.generateBytesForMessage(message));
        }
        final List<StateMachineTrace> messageTraces = this.generateTraces(sm);
        final Function1<StateMachineTrace, Boolean> _function_1 = (StateMachineTrace t) -> {
          String _name_1 = t.getState().getName();
          String _name_2 = sm.getEndState().getName();
          return Boolean.valueOf((!Objects.equal(_name_1, _name_2)));
        };
        Iterable<StateMachineTrace> _filter_1 = IterableExtensions.<StateMachineTrace>filter(messageTraces, _function_1);
        for (final StateMachineTrace messageTrace : _filter_1) {
          {
            String _folderLocation = messageTrace.getFolderLocation();
            String _traceDotFileName = messageTrace.getTraceDotFileName();
            String _plus_1 = (_folderLocation + _traceDotFileName);
            fsa.generateFile(_plus_1, this.generateDotGraphForTrace(sm, messageTrace));
            String _folderLocation_1 = messageTrace.getFolderLocation();
            String _traceFileName = messageTrace.getTraceFileName();
            String _plus_2 = (_folderLocation_1 + _traceFileName);
            fsa.generateFile(_plus_2, this.generateTraceFileForTrace(sm, messageTrace));
          }
        }
        fsa.generateFile("setup.sh", this.generateBashFile(sm, messageTraces));
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Generate the DOT graph of the whole state machine, as a visual representation.
   */
  public CharSequence generateGlobalDotGraph(final StateMachine sm) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("digraph g {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    String _name = sm.getInitState().getName();
    _builder.append(_name, "\t");
    _builder.append(" [shape=\"none\" label=\"");
    String _name_1 = sm.getInitState().getName();
    _builder.append(_name_1, "\t");
    _builder.append("\"];");
    _builder.newLineIfNotEmpty();
    {
      EList<State> _states = sm.getStates();
      for(final State state : _states) {
        _builder.append("\t");
        String _name_2 = state.getName();
        _builder.append(_name_2, "\t");
        _builder.append(" [shape=\"Mrecord\" label=\"");
        String _name_3 = state.getName();
        _builder.append(_name_3, "\t");
        _builder.append("\"];");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    String _name_4 = sm.getEndState().getName();
    _builder.append(_name_4, "\t");
    _builder.append(" [shape=\"Mrecord\" peripheries=2 label=\"");
    String _name_5 = sm.getEndState().getName();
    _builder.append(_name_5, "\t");
    _builder.append("\"];");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    {
      EList<MessageTransition> _transitions = sm.getTransitions();
      for(final MessageTransition transition : _transitions) {
        _builder.append("\t");
        CharSequence _dotGraphTransitionText = this.getDotGraphTransitionText(transition, sm);
        _builder.append(_dotGraphTransitionText, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * Generate transition text for a given transition.
   */
  public CharSequence getDotGraphTransitionText(final MessageTransition mt, final StateMachine sm) {
    StringConcatenation _builder = new StringConcatenation();
    {
      State _currentState = mt.getCurrentState();
      boolean _tripleNotEquals = (_currentState != null);
      if (_tripleNotEquals) {
        String _name = mt.getCurrentState().getName();
        _builder.append(_name);
        _builder.append(" -> ");
        {
          State _nextState = mt.getNextState();
          boolean _tripleNotEquals_1 = (_nextState != null);
          if (_tripleNotEquals_1) {
            String _name_1 = mt.getNextState().getName();
            _builder.append(_name_1);
          } else {
            String _name_2 = mt.getCurrentState().getName();
            _builder.append(_name_2);
          }
        }
        _builder.append(" [label=\"");
        String _labelForTransition = this.getLabelForTransition(mt);
        _builder.append(_labelForTransition);
        _builder.append("\"];");
        _builder.newLineIfNotEmpty();
      } else {
        String _name_3 = sm.getInitState().getName();
        _builder.append(_name_3);
        _builder.append(" -> ");
        {
          State _nextState_1 = mt.getNextState();
          boolean _tripleNotEquals_2 = (_nextState_1 != null);
          if (_tripleNotEquals_2) {
            String _name_4 = mt.getNextState().getName();
            _builder.append(_name_4);
          } else {
            String _name_5 = sm.getInitState().getName();
            _builder.append(_name_5);
          }
        }
        _builder.append(" [label=\"");
        String _labelForTransition_1 = this.getLabelForTransition(mt);
        _builder.append(_labelForTransition_1);
        _builder.append("\"];");
        _builder.newLineIfNotEmpty();
        {
          EList<State> _states = sm.getStates();
          for(final State state : _states) {
            String _name_6 = state.getName();
            _builder.append(_name_6);
            _builder.append(" -> ");
            {
              State _nextState_2 = mt.getNextState();
              boolean _tripleNotEquals_3 = (_nextState_2 != null);
              if (_tripleNotEquals_3) {
                String _name_7 = mt.getNextState().getName();
                _builder.append(_name_7);
              } else {
                String _name_8 = state.getName();
                _builder.append(_name_8);
              }
            }
            _builder.append(" [label=\"");
            String _labelForTransition_2 = this.getLabelForTransition(mt);
            _builder.append(_labelForTransition_2);
            _builder.append("\"];");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
  
  /**
   * Generate a DOT graph for a given trace going through the state machine
   */
  public CharSequence generateDotGraphForTrace(final StateMachine sm, final StateMachineTrace trace) {
    CharSequence _xblockexpression = null;
    {
      String transitionStr = "";
      String previousStateName = sm.getInitState().getName();
      LinkedList<MessageTransition> _shortestPath = trace.getShortestPath();
      for (final MessageTransition transition : _shortestPath) {
        {
          String _transitionStr = transitionStr;
          String _name = transition.getNextState().getName();
          String _plus = ((previousStateName + " -> ") + _name);
          String _plus_1 = (_plus + "[label=\"");
          String _labelForTransition = this.getLabelForTransition(transition);
          String _plus_2 = (_plus_1 + _labelForTransition);
          String _plus_3 = (_plus_2 + "\"];\n");
          transitionStr = (_transitionStr + _plus_3);
          previousStateName = transition.getNextState().getName();
        }
      }
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("digraph g {");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      String _name = sm.getInitState().getName();
      _builder.append(_name, "\t");
      _builder.append(" [shape=\"none\" label=\"");
      String _name_1 = sm.getInitState().getName();
      _builder.append(_name_1, "\t");
      _builder.append("\"];");
      _builder.newLineIfNotEmpty();
      {
        LinkedList<MessageTransition> _shortestPath_1 = trace.getShortestPath();
        for(final MessageTransition transition_1 : _shortestPath_1) {
          _builder.append("\t");
          String _name_2 = transition_1.getNextState().getName();
          _builder.append(_name_2, "\t");
          _builder.append(" [shape=\"Mrecord\" label=\"");
          String _name_3 = transition_1.getNextState().getName();
          _builder.append(_name_3, "\t");
          _builder.append("\"];");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.newLine();
      _builder.append("\t");
      _builder.append(transitionStr, "\t");
      _builder.newLineIfNotEmpty();
      _builder.append("}");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  /**
   * Generate a tracefile that contains the instructions for the fuzzing corpus
   */
  public String generateTraceFileForTrace(final StateMachine sm, final StateMachineTrace trace) {
    String traceFileInstructions = "";
    LinkedList<MessageTransition> _shortestPath = trace.getShortestPath();
    for (final MessageTransition transition : _shortestPath) {
      {
        EList<Message> _receivedMessages = transition.getReceivedMessages();
        boolean _tripleNotEquals = (_receivedMessages != null);
        if (_tripleNotEquals) {
          EList<Message> _receivedMessages_1 = transition.getReceivedMessages();
          for (final Message message : _receivedMessages_1) {
            String _traceFileInstructions = traceFileInstructions;
            String _fileNameForMessage = Utils.getFileNameForMessage(message);
            String _plus = ("sendFile " + _fileNameForMessage);
            String _plus_1 = (_plus + "\n");
            traceFileInstructions = (_traceFileInstructions + _plus_1);
          }
        }
        EList<Message> _sentMessages = transition.getSentMessages();
        boolean _tripleNotEquals_1 = (_sentMessages != null);
        if (_tripleNotEquals_1) {
          String _traceFileInstructions_1 = traceFileInstructions;
          String _messageListAsStr = this.getMessageListAsStr(transition.getSentMessages());
          String _plus_2 = ("receiveMessage " + _messageListAsStr);
          String _plus_3 = (_plus_2 + "\n");
          traceFileInstructions = (_traceFileInstructions_1 + _plus_3);
        }
      }
    }
    return traceFileInstructions.trim();
  }
  
  public String getMessageListAsStr(final List<Message> messages) {
    StringBuffer resultStr = new StringBuffer();
    for (final Message message : messages) {
      {
        int _length = resultStr.length();
        boolean _notEquals = (_length != 0);
        if (_notEquals) {
          resultStr.append(",");
        }
        resultStr.append(message.getName());
      }
    }
    return resultStr.toString();
  }
  
  /**
   * Generate label for a state transition in the graph
   */
  public String getLabelForTransition(final MessageTransition messageTransition) {
    String labelString = "";
    int _size = messageTransition.getReceivedMessages().size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      for (int i = 0; (i < messageTransition.getReceivedMessages().size()); i++) {
        {
          Message rMessage = messageTransition.getReceivedMessages().get(i);
          String _labelString = labelString;
          String _name = rMessage.getName();
          labelString = (_labelString + _name);
          int _size_1 = messageTransition.getReceivedMessages().size();
          int _minus = (_size_1 - 1);
          boolean _lessThan = (i < _minus);
          if (_lessThan) {
            String _labelString_1 = labelString;
            labelString = (_labelString_1 + ", ");
          }
        }
      }
    } else {
      String _labelString = labelString;
      labelString = (_labelString + "Empty");
    }
    String _labelString_1 = labelString;
    labelString = (_labelString_1 + " / ");
    int _size_1 = messageTransition.getSentMessages().size();
    boolean _greaterThan_1 = (_size_1 > 0);
    if (_greaterThan_1) {
      for (int i = 0; (i < messageTransition.getSentMessages().size()); i++) {
        {
          Message sMessage = messageTransition.getSentMessages().get(i);
          String _labelString_2 = labelString;
          String _name = sMessage.getName();
          labelString = (_labelString_2 + _name);
          int _size_2 = messageTransition.getSentMessages().size();
          int _minus = (_size_2 - 1);
          boolean _lessThan = (i < _minus);
          if (_lessThan) {
            String _labelString_3 = labelString;
            labelString = (_labelString_3 + ", ");
          }
        }
      }
    } else {
      String _labelString_2 = labelString;
      labelString = (_labelString_2 + "Empty");
    }
    return labelString;
  }
  
  /**
   * Generate traces to reach each state in the state machine
   */
  public List<StateMachineTrace> generateTraces(final StateMachine sm) {
    return this.calculateShortestPath(sm);
  }
  
  /**
   * Calculate the shortest path through the statemachine to reach each node.
   */
  public List<StateMachineTrace> calculateShortestPath(final StateMachine sm) {
    try {
      List<StateMachineTrace> unvisitedNodes = new LinkedList<StateMachineTrace>();
      List<StateMachineTrace> visitedNodes = new LinkedList<StateMachineTrace>();
      State _initState = sm.getInitState();
      StateMachineTrace _stateMachineTrace = new StateMachineTrace(_initState);
      unvisitedNodes.add(_stateMachineTrace);
      while ((unvisitedNodes.size() > 0)) {
        {
          StateMachineTrace currentNode = unvisitedNodes.stream().sorted().findFirst().get();
          unvisitedNodes.remove(currentNode);
          List<MessageTransition> _transitionsFromStateToNewState = this.getTransitionsFromStateToNewState(sm, currentNode.getState());
          for (final MessageTransition transition : _transitionsFromStateToNewState) {
            {
              State _state = this.getState(sm, transition.getNextState().getName());
              StateMachineTrace nextNode = new StateMachineTrace(_state);
              boolean _contains = visitedNodes.contains(nextNode);
              boolean _not = (!_contains);
              if (_not) {
                int _distance = currentNode.getDistance();
                int _plus = (_distance + 1);
                nextNode.setDistance(_plus);
                LinkedList<MessageTransition> _shortestPath = currentNode.getShortestPath();
                LinkedList<MessageTransition> path = new LinkedList<MessageTransition>(_shortestPath);
                path.add(transition);
                nextNode.setShortestPath(path);
                boolean _contains_1 = unvisitedNodes.contains(nextNode);
                boolean _not_1 = (!_contains_1);
                if (_not_1) {
                  unvisitedNodes.add(nextNode);
                }
              }
            }
          }
          visitedNodes.add(currentNode);
        }
      }
      return visitedNodes;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Get a list of MessageTransitions from State s, in StateMachine sm.
   */
  public List<MessageTransition> getTransitionsFromStateToNewState(final StateMachine sm, final State s) {
    List<MessageTransition> allTransitions = CollectionLiterals.<MessageTransition>newLinkedList();
    allTransitions.addAll(sm.getTransitions());
    final Function1<MessageTransition, Boolean> _function = (MessageTransition t) -> {
      return Boolean.valueOf(((!Objects.equal(t.getNextState().getName(), s.getName())) && (((t.getCurrentState() != null) && Objects.equal(t.getCurrentState().getName(), s.getName())) || (t.getCurrentState() == null))));
    };
    return IterableExtensions.<MessageTransition>toList(IterableExtensions.<MessageTransition>filter(allTransitions, _function));
  }
  
  /**
   * Lookup the name reference to get the full state description
   */
  public State getState(final StateMachine sm, final String name) {
    boolean _equals = sm.getInitState().getName().equals(name);
    if (_equals) {
      return sm.getInitState();
    } else {
      boolean _equals_1 = sm.getEndState().getName().equals(name);
      if (_equals_1) {
        return sm.getEndState();
      }
    }
    final Function1<State, Boolean> _function = (State s) -> {
      String _name = s.getName();
      return Boolean.valueOf(Objects.equal(_name, name));
    };
    return IterableExtensions.<State>findFirst(sm.getStates(), _function);
  }
  
  /**
   * Generate bash file for operations
   */
  public CharSequence generateBashFile(final StateMachine sm, final List<StateMachineTrace> messageTraces) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#!/bin/bash");
    _builder.newLine();
    _builder.append("echo \"Removing old files\"");
    _builder.newLine();
    _builder.append("find . -type f -name \'*.png\' -delete");
    _builder.newLine();
    _builder.append("find . -type f -name \'*.pcap\' -delete");
    _builder.newLine();
    _builder.newLine();
    _builder.append("echo \"Generating visual representation:\"");
    _builder.newLine();
    _builder.append("dot -Tpng \"");
    String _name = sm.getName();
    _builder.append(_name);
    _builder.append(".dot\" > \"");
    String _name_1 = sm.getName();
    _builder.append(_name_1);
    _builder.append(".png\"");
    _builder.newLineIfNotEmpty();
    {
      final Function1<StateMachineTrace, Boolean> _function = (StateMachineTrace t) -> {
        String _name_2 = t.getState().getName();
        String _name_3 = sm.getEndState().getName();
        return Boolean.valueOf((!Objects.equal(_name_2, _name_3)));
      };
      Iterable<StateMachineTrace> _filter = IterableExtensions.<StateMachineTrace>filter(messageTraces, _function);
      for(final StateMachineTrace messageTrace : _filter) {
        _builder.append("dot -Tpng \"");
        String _folderLocation = messageTrace.getFolderLocation();
        String _traceDotFileName = messageTrace.getTraceDotFileName();
        String _plus = (_folderLocation + _traceDotFileName);
        _builder.append(_plus);
        _builder.append("\" > \"");
        String _folderLocation_1 = messageTrace.getFolderLocation();
        String _tracePngFileName = messageTrace.getTracePngFileName();
        String _plus_1 = (_folderLocation_1 + _tracePngFileName);
        _builder.append(_plus_1);
        _builder.append("\"");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("echo \"Generating .pcap files for messages:\"");
    _builder.newLine();
    {
      final Function1<Message, Boolean> _function_1 = (Message m) -> {
        int _size = m.getStructEntries().size();
        return Boolean.valueOf((_size > 0));
      };
      Iterable<Message> _filter_1 = IterableExtensions.<Message>filter(sm.getMessages(), _function_1);
      for(final Message message : _filter_1) {
        _builder.append("od -Ax -tx1 -v \"");
        String _fileNameForMessage = Utils.getFileNameForMessage(message);
        _builder.append(_fileNameForMessage);
        _builder.append("\" | text2pcap -T 443,443 - $2 \"");
        String _fileNameForPcapMessage = Utils.getFileNameForPcapMessage(message);
        _builder.append(_fileNameForPcapMessage);
        _builder.append("\"");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
}
