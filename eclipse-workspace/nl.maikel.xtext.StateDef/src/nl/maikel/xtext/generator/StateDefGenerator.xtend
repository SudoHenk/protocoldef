/*
 * generated by Xtext 2.14.0
 */
package nl.sudohenk.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import nl.sudohenk.xtext.stateDef.StateMachine
import java.util.List
import java.util.LinkedList
import nl.sudohenk.xtext.stateDef.MessageTransition
import nl.sudohenk.xtext.stateDef.State
import nl.sudohenk.xtext.stateDef.Message

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class StateDefGenerator extends AbstractGenerator {
		
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val sm = resource.allContents.head as StateMachine; 
		if (sm !== null) {
			// generate global DOT graph
			fsa.generateFile(sm.name + ".dot", generateGlobalDotGraph(sm));
			
			// generate messages
			val MessageGenerator messageGen = new MessageGenerator(sm);
			for(message : sm.messages.filter[m | m.structEntries.size > 0]) {
				fsa.generateFile(Utils.getFileNameForMessage(message), messageGen.generateBytesForMessage(message));
			}
			
			// generate traces
			val messageTraces = generateTraces(sm);
			for (messageTrace : messageTraces.filter[t | t.state.name != sm.endState.name]) {
				// generate visual graph
				fsa.generateFile(messageTrace.folderLocation+messageTrace.traceDotFileName, generateDotGraphForTrace(sm, messageTrace));
				
				// generate tracefile for the corpus
				fsa.generateFile(messageTrace.folderLocation+messageTrace.traceFileName, generateTraceFileForTrace(sm, messageTrace))
				
				// LIST OF TODOS
				// DSL:
				// - Correctly set LENGTH fields in records (1/2 day)
				// - Correctly set variable size fields such as CipherSuites (1/2 day)
				// - Generate variations on messages such as Alerts with all possible ENUM vals (1 day)
				// - Expand State Machine to cover all states (1 day)
				
				// Corpus:
				// - Implement "receiveMessage" validation (few hours)
				// - Test with generated messages (1-2 days)
				//
				// Results:
				// - GCOV 1.0.1f run with only "AcceptConnection" trace (1/2 day)
				// - GCOV 1.0.1f run with only "HandshakeCompleted" trace (1/2 day)
				// - GCOV 1.0.1f run with multiple traces, generated from DSL (1 day)
				//
				// - AFL 1.1.1d run with TLSv1.3 (>2 days)
				// - GCOV 1.1.1d run with TLSv1.3 with only "AcceptConnection" trace (1/2 day)
				// - GCOV 1.1.1d run with TLSv1.3 with only "HandshakeCompleted" trace (1/2 day)
				// - GCOV 1.1.1d run with TLSv1.3 with multiple traces, generated from DSL (1 day)
				
			}
			// generate bash file
			fsa.generateFile("setup.sh", generateBashFile(sm, messageTraces));
		}
	}
	
	/**
	 * Generate the DOT graph of the whole state machine, as a visual representation.
	 */
	def generateGlobalDotGraph(StateMachine sm) {
		'''
		digraph g {
			
			«sm.initState.name» [shape="none" label="«sm.initState.name»"];
			«FOR state : sm.states»
				«state.name» [shape="Mrecord" label="«state.name»"];
			«ENDFOR»
			«sm.endState.name» [shape="Mrecord" peripheries=2 label="«sm.endState.name»"];
			
			«FOR transition : sm.transitions»
				«getDotGraphTransitionText(transition, sm)»
			«ENDFOR»
			
		}
		'''
	}
	
	/**
	 * Generate transition text for a given transition.
	 */
	def getDotGraphTransitionText(MessageTransition mt, StateMachine sm) {
		'''
		«IF mt.currentState !== null»
			«mt.currentState.name» -> «IF mt.nextState !== null»«mt.nextState.name»«ELSE»«mt.currentState.name»«ENDIF» [label="«getLabelForTransition(mt)»"];
		«ELSE»
			«sm.initState.name» -> «IF mt.nextState !== null»«mt.nextState.name»«ELSE»«sm.initState.name»«ENDIF» [label="«getLabelForTransition(mt)»"];
			«FOR state : sm.states»
				«state.name» -> «IF mt.nextState !== null»«mt.nextState.name»«ELSE»«state.name»«ENDIF» [label="«getLabelForTransition(mt)»"];
			«ENDFOR»
		«ENDIF»
		'''
	}
	
	/**
	 * Generate a DOT graph for a given trace going through the state machine
	 */
	def generateDotGraphForTrace(StateMachine sm, StateMachineTrace trace) {
		var transitionStr = ""
		var previousStateName = sm.initState.name
		for (transition : trace.shortestPath) {
			transitionStr += previousStateName + " -> " + transition.nextState.name + "[label=\"" + getLabelForTransition(transition) + "\"];\n" 
			previousStateName = transition.nextState.name
		}
		
		'''
		digraph g {
			
			«sm.initState.name» [shape="none" label="«sm.initState.name»"];
			«FOR transition : trace.shortestPath»
				«transition.nextState.name» [shape="Mrecord" label="«transition.nextState.name»"];
			«ENDFOR»

			«transitionStr»
		}
		'''
	}
	
	/**
	 * Generate a tracefile that contains the instructions for the fuzzing corpus
	 */
	def generateTraceFileForTrace(StateMachine sm, StateMachineTrace trace) {
		var traceFileInstructions = ""
		for (transition : trace.shortestPath) {
			if(transition.receivedMessages !== null) {
				for(message : transition.receivedMessages) {
					traceFileInstructions += "sendFile " + Utils.getFileNameForMessage(message) + "\n"
				}
			}
			if(transition.sentMessages !== null) {
				traceFileInstructions += "receiveMessage " + getMessageListAsStr(transition.sentMessages) + "\n"
			}
		}
		return traceFileInstructions.trim
	}
	
	def getMessageListAsStr(List<Message> messages) {
		var StringBuffer resultStr = new StringBuffer
		for (message : messages) {
			if (resultStr.length() != 0) {
				resultStr.append(",");
			}
			resultStr.append(message.name)
		}
		return resultStr.toString
	}
	
	/**
	 * Generate label for a state transition in the graph
	 */
	def getLabelForTransition(MessageTransition messageTransition) {
		var labelString = ""
		if(messageTransition.receivedMessages.size() > 0) {
			for (var i = 0; i < messageTransition.receivedMessages.size(); i++) {
				var rMessage = messageTransition.receivedMessages.get(i)
				labelString += rMessage.name
				if(i < messageTransition.receivedMessages.size()-1) {
					labelString += ", "
				}
			}
		} else {
			labelString += "Empty"
		}
		labelString += " / ";
		if(messageTransition.sentMessages.size() > 0) {
			for (var i = 0; i < messageTransition.sentMessages.size(); i++) {
				var sMessage = messageTransition.sentMessages.get(i)
				labelString += sMessage.name
				if(i < messageTransition.sentMessages.size()-1) {
					labelString += ", "
				}
			}
		} else {
			labelString += "Empty"
		}
		
		return labelString;
	}
	
	/**
	 * Generate traces to reach each state in the state machine
	 */
	def List<StateMachineTrace> generateTraces(StateMachine sm) {
		return calculateShortestPath(sm)
	}
	
	/**
	 * Calculate the shortest path through the statemachine to reach each node.
	 */
	def List<StateMachineTrace> calculateShortestPath(StateMachine sm) {
		var List<StateMachineTrace> unvisitedNodes = new LinkedList();
		var List<StateMachineTrace> visitedNodes = new LinkedList();
		
		unvisitedNodes.add(new StateMachineTrace(sm.initState))
		
		while(unvisitedNodes.size() > 0) {
			var currentNode = unvisitedNodes.stream().sorted().findFirst().get()
			unvisitedNodes.remove(currentNode)
			for (transition : getTransitionsFromStateToNewState(sm, currentNode.getState)) {
				// Note that transition.nextState is a reference, not the actual State description
				var nextNode = new StateMachineTrace(getState(sm, transition.nextState.name))
				if(!visitedNodes.contains(nextNode)) {
					nextNode.distance = currentNode.getDistance + 1
					var path = new LinkedList<MessageTransition>(currentNode.getShortestPath)
					path.add(transition)
					nextNode.shortestPath = path
					if(!unvisitedNodes.contains(nextNode)) {
						unvisitedNodes.add(nextNode)
					}
				}
			}
			visitedNodes.add(currentNode)
		}
		return visitedNodes	
	}
	
	/**
	 * Get a list of MessageTransitions from State s, in StateMachine sm.
	 */
	def List<MessageTransition> getTransitionsFromStateToNewState(StateMachine sm, State s) {
		var List<MessageTransition> allTransitions = newLinkedList
		allTransitions.addAll(sm.transitions)
		return allTransitions.filter[t | t.nextState.name != s.name && ((t.currentState !== null && t.currentState.name == s.name) || t.currentState === null)].toList
	}
	
	/**
	 * Lookup the name reference to get the full state description
	 */
	def State getState(StateMachine sm, String name) {
		if(sm.initState.name.equals(name)) {
			return sm.initState;
		} else if(sm.endState.name.equals(name)) {
			return sm.endState;
		}
		return sm.states.findFirst[s | s.name == name]
	}

	/**
	 * Generate bash file for operations
	 */
	def generateBashFile(StateMachine sm, List<StateMachineTrace> messageTraces) {
		'''
		#!/bin/bash
		echo "Removing old files"
		find . -type f -name '*.png' -delete
		find . -type f -name '*.pcap' -delete
		
		echo "Generating visual representation:"
		dot -Tpng "«sm.name».dot" > "«sm.name».png"
		«FOR messageTrace : messageTraces.filter[t | t.state.name != sm.endState.name]»
			dot -Tpng "«messageTrace.folderLocation+messageTrace.traceDotFileName»" > "«messageTrace.folderLocation+messageTrace.tracePngFileName»"
		«ENDFOR»
		
		echo "Generating .pcap files for messages:"
		«FOR message : sm.messages.filter[m | m.structEntries.size > 0]»
			od -Ax -tx1 -v "«Utils.getFileNameForMessage(message)»" | text2pcap -T 443,443 - $2 "«Utils.getFileNameForPcapMessage(message)»"
		«ENDFOR»
		'''
	}
}
